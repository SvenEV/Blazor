@inherits UIElement
@inject HttpClient Http

<img style="@LayoutCss" src="@Source" />

@functions{

    public string Source { get; set; }

    public Stretch Stretch { get; set; } = Stretch.Uniform;

    public StretchDirection StretchDirection { get; set; } = StretchDirection.Both;

    private Point _imageSize;

    protected override async Task OnParametersSetAsync()
    {
        try
        {
            if (string.IsNullOrWhiteSpace(Source))
                return;

            var err = await Http.GetStringAsync(Source);
            UILog.Write("IMAGE", $"Error info: " + err);

            using (var stream = await Http.GetStreamAsync(Source))
            {
                UILog.Write("IMAGE", $"Got stream for '{Source}': {stream.Length} bytes");
                var imageInfo = SixLabors.ImageSharp.Image.Identify(stream);
                UILog.Write("IMAGE", $"Got image info '{Source}'");
                _imageSize = new Point(imageInfo.Width, imageInfo.Height);
                UILog.Write("IMAGE", $"Image size is {_imageSize} for '{Source}'");
            }
        }
        catch (Exception e)
        {
            UILog.Write("IMAGE", $"Failed to load image: '{Source}'. {e}");
        }
    }

    protected override Point MeasureOverride(Point availableSize) =>
        MeasureArrange(availableSize);

    protected override Point ArrangeOverride(Point finalSize) =>
        MeasureArrange(finalSize);

    private Point MeasureArrange(Point availableSize)
    {
        var scaleFactor = ComputeScaleFactor(availableSize, _imageSize, Stretch, StretchDirection);
        return _imageSize * scaleFactor;
    }

    private static Point ComputeScaleFactor(Point availableSize, Point contentSize, Stretch stretch, StretchDirection stretchDirection)
    {
        var scale = Point.One;
        var isWidthConstrained = !double.IsPositiveInfinity(availableSize.X);
        var isHeightConstrained = !double.IsPositiveInfinity(availableSize.Y);

        if (stretch != Stretch.None && (isWidthConstrained || isHeightConstrained))
        {
            scale = new Point(
                Helpers.EqualsApprox(0, contentSize.X) ? 0 : availableSize.X / contentSize.X,
                Helpers.EqualsApprox(0, contentSize.Y) ? 0 : availableSize.Y / contentSize.Y);

            if (!isWidthConstrained)
            {
                scale = scale.WithX(scale.Y);
            }
            else if (!isHeightConstrained)
            {
                scale = scale.WithY(scale.X);
            }
            else
            {
                switch (stretch)
                {
                    case Stretch.Uniform:
                        scale = Math.Min(scale.X, scale.Y) * Point.One;
                        break;

                    case Stretch.UniformToFill:
                        scale = Math.Max(scale.X, scale.Y) * Point.One;
                        break;
                }
            }

            // Account for stretch direction
            var minScale = (stretchDirection == StretchDirection.UpOnly) ? Point.One : Point.Zero;
            var maxScale = (stretchDirection == StretchDirection.DownOnly) ? Point.One : Point.PositiveInfinity;
            scale = Point.Clamp(scale, minScale, maxScale);
        }

        return scale;
    }
}