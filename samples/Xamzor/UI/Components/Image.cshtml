@inherits UIElement

<img class="Image" style="@LayoutCss user-select: none; -ms-user-select: none;"
     src="@Source" draggable="@(IsDraggable ? "true" : "false")" />

@functions{

    public string Source { get; set; }

    public bool IsDraggable { get; set; } = false;

    public ImageStretch Stretch { get; set; } = ImageStretch.Uniform;

    public StretchDirection StretchDirection { get; set; } = StretchDirection.Both;

    private Point _imageSize;

    protected override async Task OnParametersSetAsync()
    {
        if (_imageSize != Point.Zero || string.IsNullOrWhiteSpace(Source))
            return;

        _imageSize = await ImageMeasureInterop.MeasureImageAsync(Source);
        RecalculateLayout();
    }

    protected override Point MeasureOverride(Point availableSize) =>
        MeasureArrange(availableSize);

    protected override Point ArrangeOverride(Point finalSize) =>
        MeasureArrange(finalSize);

    private Point MeasureArrange(Point availableSize)
    {
        var scaleFactor = ComputeScaleFactor(availableSize, _imageSize, Stretch, StretchDirection);
        return _imageSize * scaleFactor;
    }

    private static Point ComputeScaleFactor(Point availableSize, Point contentSize, ImageStretch stretch, StretchDirection stretchDirection)
    {
        var scale = Point.One;
        var isWidthConstrained = !double.IsPositiveInfinity(availableSize.X);
        var isHeightConstrained = !double.IsPositiveInfinity(availableSize.Y);

        if (stretch != ImageStretch.None && (isWidthConstrained || isHeightConstrained))
        {
            scale = new Point(
                Helpers.EqualsApprox(0, contentSize.X) ? 0 : availableSize.X / contentSize.X,
                Helpers.EqualsApprox(0, contentSize.Y) ? 0 : availableSize.Y / contentSize.Y);

            if (!isWidthConstrained)
            {
                scale = scale.WithX(scale.Y);
            }
            else if (!isHeightConstrained)
            {
                scale = scale.WithY(scale.X);
            }
            else
            {
                switch (stretch)
                {
                    case ImageStretch.Uniform:
                        scale = Math.Min(scale.X, scale.Y) * Point.One;
                        break;

                    case ImageStretch.UniformToFill:
                        scale = Math.Max(scale.X, scale.Y) * Point.One;
                        break;
                }
            }

            // Account for stretch direction
            var minScale = (stretchDirection == StretchDirection.UpOnly) ? Point.One : Point.Zero;
            var maxScale = (stretchDirection == StretchDirection.DownOnly) ? Point.One : Point.PositiveInfinity;
            scale = Point.Clamp(scale, minScale, maxScale);
        }

        return scale;
    }
}